The daxlua module is logic module that uses the Lua programming language to
write scripts that are executed and have access to the \opendax tags.

Scripts are written in normal text files and stored in any arbitrary location in
the filesystem.  They can be run either on a periodic basis or they can be triggered
by tag events.

To run scripts on a periodic basis they need to be assigned to an \textit{interval thread}.
Interval threads sleep for a period of time and then wake up and run all of the scripts
that are assigned to them.  The user has complete control over all of the interval threads
that are created in the system and which scripts are assigned to them.

The other method of running scripts is to assign a trigger to them.  Triggers in the \textit{daxlua}
module are nothing more than \opendax events.  When the event is received from the server,
the associated script will be executed.

These triggered scripts are not executed directly but rather, they are stored on an execution
queue and run by one of several \textit{queue threads}.  These threads are started early in the system
and they simply wait until a script is placed on the queue, then one of the threads will retrieve that
script from the queue and execute it.  The number of queues that are started by the module is a
configuration for the user.

Scripts can also be enabled or disabled in one of several ways.  The enabled state of the script can
be chosen in the main configuration file and that will be the state of the script when started.  Scripts
can be enabled or disabled via triggers that are nothing more than \opendax events from the tag server, or
they can be enabled / disabled from one another.  There is also a Lua function that allows scripts
to disable themselves.  This is handy when a script simply needs to only be scheduled for a short time, until
the job is done and then disable themselves.

\section{Configuration}

The module looks for the file \texttt{daxlua.conf}.  Not having a proper configuration is a fatal error
as it makes no sense to run with defaults.  The normal module configuration options apply to daxlua
as well as many other.

\begin{verbatim}
	-- Number of worker threads for handling event trigger scripts
	event_thread_count = 8
	-- Size of the event queue.  This is the queue that holds the
    -- scripts between the time the server sends the event and
    -- the worker threads can execute the script.
	event_queue_size = 128

	-- Adds an interval thread.  These threads will run all of
	-- the scripts that are assigned to them by name every time
	-- the given time has elapsed

	add_interval_thread("fast", 500)
	add_interval_thread("1sec", 1000)
	add_interval_thread("slow", 2000)

\end{verbatim}

The \texttt{event\_thread\_count} attribute is the number of threads that will be created to handle
scripts that are going to be run by triggers.  Scripts are not released from the thread that
they are assigned to until they have completed so if there are many scripts that take a long
time to run then it would make sense to have more scripts.  For a few very short duration scripts
fewer threads can be used.  Some experimentation may be necessary to determine the optimal thread
count for the users application.

The \texttt{event\_queue\_size} attribute is the size of the queue that will be used to hold events that
need to be processed by the event threads.  If this queue fills up then events will be lost and
errors will be placed in the log file.  This is nothing more than an array of pointers so it is
fairly inexpensive in terms of memory usage.  The queue should be big enough to handle all the events
that might happen simultaneously.

The \texttt{add\_interval\_thread()} configuration function causes the module to create a thread
that can later have scripts assigned to them.  There are two arguments to the function.  The first
is the name of the thread (this will be referred to later by the scripts) and the desired interval.

The interval threads are at the mercy of the operating system in terms of their actual scheduling.
If realtime deterministic scheduling is required then this is probably not the mechanism.  There
are ways within the threads to determine the time between executions of the thread so that fairly good
integrations can be done with scripts but it may not be deterministic enough for every use case.

\begin{verbatim}
s = {}

s.name = "demo1"    -- Unique name for the script
s.filename = root.."demo1.lua"  -- The path to the script
s.enable = false    -- If false the script will not run
s.fail_on_error = true
s.thread = "fast"   -- The name of the interval thread
                    -- that we wish to be assigned to
s.enable_trigger = {tag="s_enable", count=0, type="SET", value=0}
s.disable_trigger = {tag="s_disable", count=0, type="SET", value=0}

-- Once the table has been configured, pass it to 'add_script()'
add_script(s)

\end{verbatim}

Above is an example of how scripts are configured.  First we create a table...

\begin{verbatim}
	s = {}
\end{verbatim}

The we fill out that table with entries.  Most of these entries should be self-explanatory.  \texttt{name}
is a unique name given to the script.  This is necessary for referring to this particular script
within the configuration but also from within the scripts.

The filename should be a proper filesystem location of the Lua file that we wish to associate with this script.
The \texttt{root} variable that is shown is an easy way to define a path to where all of our scripts are
located.  Since our configuration is nothing more than a Lua script itself, we can use concatenation
tricks like this to save us some work.  We can also use loops and other language features if it is
appropriate.

If \texttt{enable} is set to \texttt{false} then the script will be assigned to the proper script but
it will not be executed until it is enabled my some mechanism.  Either by another script or a trigger.

If \texttt{fail\_on\_error} is set to true the script will fail (no longer be executed) if
an error is raised by the script.  Errors that are caught in the scipr (by pcall() or similar)
will not cause the failure.  To allow a script to continue to run after an error is caught
this will need to be set to false.  The default is true.

\texttt{thread} is the name of the interval thread, that we wish to assign the script to.  Each
script can only be assigned to one thread.

The \texttt{enable\_trigger} and \texttt{disable\_trigger} attributes are tables that represent the \opendax
event that we wish to enable or disable the script.  Four pieces of information define an event but
not all are appropriate for each event type.  Detailed descriptions of the event system are given
elsewhere in this manual\footnote{Probably not done yet, documentation is still a work in progress}.

To configure a triggered script the \textit{trigger} attribute should be set.  This attribute is
similar to the enable / disable triggers described above except that when the event is received
from the tag server the script is placed on the queue to be executed.

\begin{verbatim}
	s.trigger = {tag="triggerdemo", count=0, type="CHANGE", value=0}
    s.auto_run = false
\end{verbatim}

The \textit{trigger} attribute and the \textit{thread} attribute can be set for each script and this
is not an error at the moment.  This would essentially cause the script to be executed within
the interval thread to which it is assigned as well as be executed when triggered.  A warning will
be generated in the log since this is probably not the desired behavior but it may work.  It should
be noted that the script only exists in one place so the context between executions will be the
same regardless of whether it was executed by the interval thread or by a trigger.  It has not
been tested so you are on your own here.

Any data that is associated with the trigger event will be stored in the global variable
\texttt{\_trigger\_data} so the Lua script will have access to that data without having to query
the tagserver.

If \texttt{auto\_run} is set to true the triggered script will be run at least once during
module startup.  This initial run will not be the result of the trigger event being received
from the server so the \texttt{\_trigger\_data} variable will be \textit{nil}.  The default
is false.

Once we have all the data in the script table we can pass it to the \texttt{add\_script()} configuration
function to actually create the script.

There two types of global data that can be assigned to the scripts before and/or after they are
executed.  The first kind of global data is a \textit{global tag}.  These are \opendax tags that will
either be read from the tagserver just before the script is executed, written to the tagserver
after the execution of the script or both.

To add a global tag to the system, use the folowing function...

\begin{verbatim}
	add_global_tag(s.name, "DEMOTAG", "DAXTAG", READ + WRITE)
\end{verbatim}

The first argument to the function is the name of the script that we wish to assign the tag to.
Since we still have the name stored in the table we simply use that value here.  Any string can
be used as long as it matches a script that has already been created with \texttt{add\_script()}.

The second argument to the \texttt{add\_global\_tag()} function is the name that will be given to
the global variable in Lua.

The third argument is the \opendax tag that we wish associate this data with.  It can be any
valid string that represents a tag in \opendax.  Arrays and CDTs are allowed and the module
will convert them to the appropriate Lua value / object.  For example, say the tag \texttt{DEMOTAG}
exists in the tagserver and it is an array of 8 double integers (DINT).  If we use "DEMOTAG" as the
name here then we will get a table in Lua with all 8 of the integers.  If we use "DEMOTAG[4]" here
we will get a single integer that is the fifth element in the array.\footnote{It is worth remembering
Lua starts numbering array elements at 1 instead of 0.  This is different than how it is represented in
the tagserver.  DEMOTAG[4] would be the fifth element in the tagserver but the fourth in Lua.}

The fourth argument is the mode of the global.  It is either READ, WRITE or the sum of those.  If
it is set to READ then the tagserver will be queried for the given tag just before the script
is executed and the value placed in the global Lua variable.  If WRITE is given then the value
will be read from the global Lua variable and then written out to the tagserver immediately after
the script executes.  It should be noted that the value only changes within the Lua script as
the script is executed.  It does not change in the tag server until after the script finishes.
There is a mechanism within the scripts that we can use to write values to the tagserver during
the script execution.  If the mode is set to READ + WRITE then it will be read from the server
just before execution and then written back to the server when the script is done.

In the given case if we write a value to the variable \texttt{DEMOTAG} in our Lua script
that value will be written to the \opendax tag, \texttt{DAXTAG}.

The same Lua file can be assigned to different scripts and different tags can be read from the
tag server into the same global Lua variable.  This allows us to write the script once but use
it for multiple different tags within the tagserver.

As many global tags can be assigned to a script as we wish but keep in mind it causes a read and/or
write cycle to the server so performance could become an issue.\footnote{Some optimizations can be done
here with tag groups but this has not yet been implemented.  The hope is that it will be invisible
to the user once it is done.}

Another piece of data that can be assigned to the individual scripts is a \textit{global static}
variable.  This is simply a value that is configured for the script that will always be
available when the script runs.

\begin{verbatim}
	add_global_static(s.name, "VARNAME1", true)
	add_global_static(s.name, "VARNAME2", 123.2)
	add_global_static(s.name, "VARNAME3", "some string")
\end{verbatim}

The first argument to \texttt{add\_global\_static()} is the name of the script.  The second
argument is the name that will be given to the global variable within the Lua script and
the third is the value.  This is a way to pass arguments to a script.  It could be used
to differentiate between scripts.  It's more efficient than global tags since there is no
interaction with the server but it is static.  The value passed can be a boolean, a number,
a string or \textit{nil} and that is all.  It turns out that it is surprisingly difficult
to move complex values like Lua tables from one Lua context (the configuration) to another
(the script).  If this becomes necessary in the future it can be added but it seems like it's
not worth the effort at this point.

Global static variables can be changed within the script as its executing as can any Lua
global variable but the next time the script is executed it will be returned to the
configured value.

Using Lua as our configuration language makes this a very powerful system.  Any Lua language
feature can be used to generate the tables and call the functions that configure the module.
Including loops, flow control, functions and file inclusions.
This is true of all the modules in \opendax{} and it is the 'killer feature' of
the system.  It can be confusing but such is the case for many things that are this powerful
and flexible.

\section{Script Writing}

The Lua scripts that we execute in this module should be scripts that execute and then
end.  If a script stays running for a long time it could hang up the thread to which it
is assigned and block other scripts from running.

The exectution order of the scripts is same as the order in which they are added in the
configuration file by the \texttt{add\_script()} function.

Execution of the script is the same whether it is run from an interval thread or if
it is triggered by an event.  The first thing that happens is the time is
recorded
that the script is being executed.  Then all of the global
tags and data are put into the script.  This may include tags that are read from the
system as well as some variables that represent status and the static globals.
Then the script is executed and once the script finishes the global tag variables
that are configured are written out to the tagserver and some housekeeping is done such
incrementing counters and storing timing information.

There are a handful of global variables and functions that are automatically available
to the Lua script when it runs.  Some were already discussed in the configuration
section.  The rest will be described shortly.

Triggered scripts will be run once, automatically by the system when they
are created.  This is to give the scripts a chance to do any initialization
that may necessary.  If the \texttt{\_first\_run} variable is \textit{true} for
these scripts then you can know that it was not called because an event
was received, rather because it was automatically run when created.  The
reason this was done is so that these scripts can have a chance to create
the actual tags that they are being triggered from or do any other
initialization that needs to be done before the system gets
started.\footnote{We may make this configurable in the future}

\subsection{\opendax{} Interface Functions}

There is a Lua package included with \opendax{} that can be used to write entire \opendax{}
modules in Lua.
In that package is a set of functions and constants that allow the programmer to access
and manipulate data in the tagserver.  The library that comprises that package is also
used in this module to give the Lua script access to the \opendax{} data.  Not all of
the functions are available however.  For example, it does not make sense to create
a connection to the server since that has already been done.  Waiting on events also
does not make sense because we don't want our scripts to run very long.

The subset of functions that are available to Lua scripts in this module are...

\begin{itemize}
	\item \textbf{cdt\_create(typename, members)} - The function is used to
	create a
	\textit{Compound Datatype}.  The first argument should be a string that
	will be used as the name of the CDT.  The second argument is a table of
	tables that defines the members of the CDT.  An example of a member
    table is given below...
    \begin{verbatim}
        members = {{"Name", "DataType", count},
                   {"AnotherNmae", "DataType", count}}
    \end{verbatim}

    This function raises errors on failure and returns a single integer that
    represents the datatype and can be used to create tags.

	\item \textbf{tag\_add(name, type, <count>)} - Adds a tag to the tagserver
	database.  The first argument is a string that
    represents the name of the new tag.  The second argument can either be an
    integer or a string that represents the data type of the tag.  The third
    argument represents the number of items created for the datatype.
    If this number is greater than 1 then an array is created.  If the count is
    not given then 1 is assumed.

    This function returns nothing on success and raises errors otherwise.

	\item \textbf{tag\_get(tag)} - Retrieve the definition of the given tag.
	The function takes a single
    argument that can either be the tagname as a string or the tag index as an
    integer.

    The function returns three values that represent the tag, name, type and
    count.

	\item \textbf{tag\_handle(tag, <count>)} - Retrieve the definition of the
	given tag.  The function takes at least one
    argument that can either be the tagname as a string or the tag index as an
    integer.  The optional second argument is the number of items we wish
    to get.

    The value that is returned is userdata that means nothing to the Lua script
    but that can be passed to the \texttt{tag\_read} and \texttt{tag\_write}
    functions.  Using handles for reading and writing tags is much more
    efficient
    than having to find the tag based on it's name every time.

	\item \textbf{tag\_read(tag, <count>)} - Read and return the value(s) of
	the given tag.  The first argument is a
    string representing the tag that we wish to read, or a handle that was
    received from  the \texttt{tag\_handle} function.  The second, optional,
    argument is the number of members that we want to read.  If the first
    argument is a handle then the count will be ignored since the handle
    fully defines the data that we want to read

    The return value depends the type and size of the tag.

	\item \textbf{tag\_write(tag, val)} - Write the value to the given tag.
	The first argument is a string
    representing the tag, or a handle that was received from  the
    \texttt{tag\_handle} function.

    The function returns nothing and raises errors on failure.

	\item \textbf{log(topic, message)} - Logs the given message to the topic.
	A list of logging topics is given below.  These are consistent throughout
	the \opendax system.

    \begin{verbatim}
        LOG_MINOR
        LOG_MAJOR
        LOG_WARN
        LOG_ERROR
        LOG_FATAL
        LOG_MODULE
        LOG_COMM
        LOG_MSG
        LOG_MSGERR
        LOG_CONFIG
        LOG_PROTOCOL
        LOG_INFO
        LOG_DEBUG
        LOG_LOGIC
        LOG_LOGICERR
        LOG_USER1
        LOG_USER2
        LOG_USER3
        LOG_USER4
        LOG_USER5
        LOG_USER6
        LOG_USER7
        LOG_USER8
        LOG_ALL
    \end{verbatim}

\end{itemize}


\subsection{daxlua Specific Functions}

Other functions that are added to the context of a script here are...

\begin{itemize}
	\item \textbf{disable\_self()} - Causes the currently executing script to be disabled
	\item \textbf{get\_executions()} - Returns the number of times our script has been executed
	\item \textbf{get\_name()} - Returns the currently executing scripts name as given in
	the configuration file.
	\item \textbf{get\_filename()} - Returns the file name of the script
	\item \textbf{get\_lastscan()} - Returns the time in microseconds that the script ran last time.
	This is roughly the number of microseconds that the system has been running.
	\item \textbf{get\_thisscan()} - Returns the time in microseconds that the script execution
	was started. This is roughly the number of microseconds that the system has been running.
	\item \textbf{get\_interval()} - Returns the time in microseconds since last time we ran.
	This is the difference of the above two times. Note that this is not how long it took the script
	to run.  It's the period between the two.  It should be fairly close to the configured interval
	that was configured for the thread.  It might be meaningless for triggered scripts but it is
	there just in case.
	\item \textbf{get\_script\_id(name)} - Returns the integer id of the
	script given by
	name or nil if not found.
	\item \textbf{get\_script\_name(id)} - Returns the name of the script
	given by
	the id or nil if out of bounds
	\item \textbf{disable\_script(name or id)} - Disables the given script.
	Returns
	the id of the script that was disabled or nil if it failed.
	\item \textbf{enable\_script(name or id)} - Enables the given script.
	Returns
	the id of the script that was enabled or nil if it failed.
\end{itemize}

Also the standard Lua packages \textit{base}, \textit{table}, \textit{string}
and \textit{math} are included.

\subsection{Global Data}

The module add some global variables to the script each time it is run.

\begin{itemize}
    \item \textbf{\_firstrun} - This variable is set to \textit{true} the
    first time the script is executed.  It will be \textit{false} afterwards.

    \item \textbf{\_trigger\_data} - Contains the data that was sent by the
    tagserver for the event.  For example, if you triggered this
    script with a CHANGE event on a tag named \textit{trigger} that is a single
    INT tag.  If some other module changes \textit{trigger} to the value of
    1234 then when your script is called, \texttt{\_trigger\_data} will be
    equal to 1234.  Arrays and CDTs can also be used as trigger events and they
    should behave as you would expect here as well. This is only available for
    scripts that were triggered and executed from the queue.  Interval scripts
    will return \textit{nill} for this variable.  It will also return
    \textit{nil} on the first run of the script since the first run is not
    triggered.
\end{itemize}

Other global variables can be configured for each script.  These are
\textit{global static} variables and \textit{global tag} variables.  These
are described in the configuration section above.

Global data that is created in the Lua script will survive between executions
since the Lua state is maintained.  This can be used to keep track of state
between executions.

An interval script may wish to run five times each time it is enabled and
then disable itself.  That could be done like this...

\begin{verbatim}
if _firstrun then
   x = 0
end

--Do some stuff here...
x = x+1

if x>=5 then
    x = 0
    disable_self()
end
\end{verbatim}

x is initialized in a block of code that only runs the first time the script
is executed.  Then it is used to keep track of how many times we have been
run.  Once we have run five times we reset x and then disable ourselves.
The next time the script is enabled (either by trigger or another script)
it will run five more times.

If this is not what you want then you will have to be careful to initialize
the global data each time the script is executed.

\subsubsection*{Notes}

Any errors that are allowed to propagate up to the calling module
will be marked as \textit{failed} and will never be executed again. Any
code within the scripts that could cause failures that may not be permanent,
(like trying to read from tags that don't yet exist) will have to be caught
or the script will be permanently disabled.
This behavior can be changed by setting the \texttt{.fail\_on\_error}
entry in the script table to false.  If this set to false the script
will continue to execute and fail.  Entries will be put in the error
log for each occurance in this case.

A future feature addition will be the ability to reload scripts from disk
while the module is running.  Once this feature is added the \textit{failed}
flag will be reset when a new script is loaded.

Be careful with triggered scripts that execute very frequently.  If several
event triggered scripts are overlapping because events are coming in faster
than the scripts can be run then the \texttt{\_trigger\_data} value may
not be reliable.  There are protections to keep the same script from running
at the same time but there are no protections for this data.  If the
script is in the queue multiple times then all of the scripts will run
with the latest \texttt{\_trigger\_data} and scripts that were waiting in
the queue when subsequent events arrived will lose their data.