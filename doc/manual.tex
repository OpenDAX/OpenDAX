\input{format.tex}

\title{OpenDAX User's Manual}
\date{June 13, 2008}
\author{Phil Birkelbach}


\begin{document}
\pagenumbering{roman}
\maketitle

\begin{flushleft}
Copyright \textcopyright 2008 - Phil Birkelbach\linebreak
All Rights Reserved
\end{flushleft}

\tableofcontents
\newpage
\pagenumbering{arabic}
\chapter{Introduction}
OpenDAX is an open source, modular, data acquisition and control system framework. It is licensed under the GPL (GNU Public License) and therefore is completely free to use and modify. OpenDAX is written primarily for Linux.  There should be no reason that it wouldn't compile on other *nix like operating systems but for now we are concentrating on Linux.

OpenDAX could be used for anything from controlling the air conditioner in a home to controlling an entire industrial facility. Depending on what modules are installed and run it could be used as the firmware for a dedicated Programable Logic Controller (PLC) or a Home Automation system. It could loosely be compared to DCS (Distributed Control System) or a SCADA (Supervisory Control and Data Acquisition) system. Eventually the system would be able to scale up to a several hundred thousand tag system. At this moment the code is far to immature to be used for anything that required reliability but we hope to get it to that point sooner or later. Much will depend on how many developers take up the challenge to help work on the code.

DAX stands for Data Acquisition and eXchange. The system works by combining a master program (opendax), a real time database server (tagserver) a library (libdax) and set of modules. The opendax server handles the starting, stopping and monitoring of process that make up a particular OpenDAX system.  It is actually an optional part of the system.  The user can start and stop each process manually if desired.

The tagbase server is the program that manages the real time data that is used throughout the system.  It could hold the temperature or pressure of a process, the status of a switch or some command data from the Human Interface to a logic module.  Each piece of information is called a 'Tag'  Each tag can be a single value or an array of values.  (Multi dimensional arrays are not supported.)  Each tag is defined as a given data type.  There are several base data types. These represent simple number types like INT or FLOAT.  It is possible to create compound
data types that are collections of the base data types and other compound data types.

The modules do all the work and communicate with the \texttt{tagbase} server through the libdax library. There could be modules for reading and writing to I/O points, data logging, alarming, machine interface, and logic. The primary interface to the tagbase server is the \texttt{daxc} module, which is a command line interface module that can
be used to read and write tags, check status and do all other types of maintenance in the tagbase server.

There is no requirement that all of the modules have to be on the same machine.  There is also no requirement that the modules be on the machine with the tag server.  Any process that is to be started by the \texttt{opendax} server will have to be on the same computer.  Modules communicate to the server by one of two mechanisms.  Either a TCP/IP connection or a \textit{local domain socket}.  The \textit{local domain socket} has the advantage of being very fast because the operating system kernel simply copies memory from one process to another.  The disadvantage is that the module that wants to use this communication mechanism must be on the same machine as the tag server. If the module is on another machine then it will have to use the TCP/IP protocol to communicate with the tag server.

The system is designed so that most of the work happens in the client library and the modules.  Since the tag
server is a bottleneck for the entire system, any work that could be offloaded to the client library and the
modules was.

\chapter{Getting Started}
\input{install.tex}

\chapter{The OpenDAX Master Server}


\chapter{The Tag Server}


\chapter{Modules}
Modules are where all the real work gets done on an OpenDAX system.  The server is the glue that holds all the modules together but the modules are where it all happens.  The OpenDAX distribution comes with a few included modules.  They are described in this chapter.  If you have received modules from other sources you'll have to consult the documentation that came with that module.

\section{Generic Module Configuration}
There are many options to be configured for each of the different modules.  For those, consult the section that describes the module that you are interested in.  There are a few options that are common to all modules and they are described here.

There are two places that modules receive configuration information.

\begin{itemize}
\item The module configuration file
\item Command line arguments
\end{itemize}

If a configuration attribute is present on the command line it will take precedence over that same attribute given in the configuration files.  An exception to this is the logging configuration.  Once logging services are added via the configuration file those services will determine how messages are logged and anything passed on the  command line will be ignored.

The module configuration file is a file that will most likely be named after the module.  For instance the configuration file for the \emph{daxlua} module is called \emph{daxlua.conf}.  These files would contain information that is specific to each module.  The \emph{daxlua} configuration contains the location of the script files to execute as an example.

The OpenDAX server and most of the modules use the Lua scripting language as the configuration file format.  The configuration files are actually executed within the server or modules process as a Lua script.  Generally the configuration is given by simple key/value pairs such as \ldots

\begin{verbatim}
daemonize = 1
socketname = "/tmp/opendax"
min_buffers = 64
\end{verbatim}

This may be sufficient for many systems but the Lua configuration system in OpenDAX is far more powerful than that.  It is also possible to import other configuration files, make decisions with \emph{if} statements, loop with \emph{for} or \emph{while}.

<<insert Lua tutorial in here somewhere>>

When the configuration file is read a global variable named \emph{calling\_module} is set to a string equal to the module's name.  This indicates to the configuration script which module is currently running the script.  You can use the variable to have multiple module configurations in a single file.  This makes it possible to separate configuration information based on function instead of by module.  For example, it would be easier to have all of the configurations for a set of flowmeters in a file called \emph{flowmeters.lua} and then include that file in each module that requires it.  The variable \emph{calling\_module} can then be used within that configuration file to determine whether it is configuring the modbus module or the historical logging module.

Here is an example \ldots

\begin{verbatim}
--Global data that is used throughout
flowmeters = {}
flowmeters[1] = {}
flowmeters[1].tagname = "FT_0101"
flowmeters[1].description = "Inlet Flow to Plant"
flowmeters[1].node    = 1
flowmeters[2] = {}
flowmeters[2].tagname = "FT_0102"
flowmeters[2].description = "Outlet Flow from Plant"
flowmeters[2].node    = 2
...more flowmeters

if calling_module == "modbus" then
  for i=1,10 do
    --use .tagname and .node to configure modbus commands
  end
end

if calling_module == "logger" then
  for i=1,10 do
    --use .tagname and .description to configure the logger
  end
end

if calling_module == "alarm" then
  for i=1,10 do
    --use .tagname and .description to configure the alarms
  end
end
\end{verbatim}

This construct gives the application developer a lot of flexibility in how he/she generates configurations for each particular application.

\chapter{Command Line Client Module}
The command line client module is called 'daxc'.  It is useful for debugging and examining or manipulating OpenDAX data in real time.  It can also be used for automating some OpenDAX tasks from a shell script.  It can be run interactively, it can read input from STDIN or a filename can be passed to it that has lists of daxc commands to execute.

\section{Configuration}
There is very little configuration that needs to be done to the daxc module.  The general configuration that is needed for all modules such as server address, ports etc are all that is really required.  There are a few extra command line options that can be used.

\subparagraph*{-f, --file}
Following '-f' or '--file' with the name of a file will cause daxc to open that file and run the commands in that file.

\subparagraph*{-x, --execute}
The execute options should be followed by a command that is to be executed by daxc.

\subparagraph*{-i, --interactive}
When the module is started with the -f or -x options the default behavior of the module is to exit when finished with those commands.  If this option is used the program will enter interactive mode after those commands are issued.

\subparagraph*{-q, --quiet}
Suppresses some output of the program while it is executing a file or a command line option.  It does nothing for interactive mode.  This is useful for running the module from shell scripts. 

\section{Commands}

\subsection{list}
The \textit{list} command lists information about tags and datatypes.  If the command is given no arguments it will simply list all of the tags in the system.  If followed by the subcommand \textit{type} it will list all of the compound data types that are configured in the currently running system.  If \textit{type} is followed by the name of one of those compound data types it will list the members of the cdt and their data type.

\subsection{cdt}
\begin{verbatim}
Usage:
daxc>cdt name m1name m1type m1count [m2name] [m2type] [m2count] [...]
\end{verbatim}
The \textit{cdt} command is used to create a compound data type.  The command should be followed by the name of the new data type and then as many member triplicates as are needed to define the type.  The triplicates include the name of the cdt member the datatype of that member and the count for the member.  For example...

\begin{verbatim}
daxc>cdt newType myInt INT 1 myDint DINT 10 myBool BOOL 32
\end{verbatim}

This would create a new compound datatype with three members.  The first member a single INT named myInt the second an array of 10 DINT's named myDint and the last one is an array of 32 BOOLs named myBool.

You can put as many triplicates after the name as needed to define the cdt.  The cdt cannot be redefined, once it is created that's it.  It'll be possible to delete unused types at some point but that feature is not yet implemented.

\subsection{add}
\begin{verbatim}
Usage:
daxc>add tagname type count
\end{verbatim}

Adds a tag to the system.  The command should be followed by the name of the new tag, the data type of the new tag and the count for the size of the tag.

\subsection{read}
\begin{verbatim}
Usage:
daxc>read tagname [count]
\end{verbatim}

The read command should be followed by the tag that is to be read.  At this point in time the tag should be a base data type tag.  This means that if you enter the name of a tag that resolves to a CDT, then read will fail with an error.  At some point the ability to read the entire tag will be implemented but at this point the string passed to read should resolve to a base type.  The count argument can be given if only a subset of the tags are to be read.

\subsection{write}
\begin{verbatim}
Usage:
daxc>write tagname value 1 [value2] [...]
\end{verbatim}

\subsection{db}
\begin{verbatim}
Usage:
daxc>db tagname [count]
\end{verbatim}

\subsection{help}
\begin{verbatim}
Usage:
daxc>help [command]
\end{verbatim}

The \textit{help} command followed by the name of another command will list information about using that command. Otherwise it simply prints a list of commands that help is available on.

\subsection{exit}
\begin{verbatim}
Usage:
daxc>exit
\end{verbatim}
The \textit{exit} command simply exits the daxc module.

\chapter{Modbus Communications Module}

\chapter{Lua Scripting Module}


\chapter{Module Development}

\end{document}
