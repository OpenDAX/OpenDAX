/*  OpenDAX - An open source data acquisition and control system
 *  Copyright (c) 2021 Phil Birkelbach
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/*
 *  Tests the string to value and value to string conversion functions
 */

#include <common.h>
#include <opendax.h>
#include <sys/types.h>

struct vtos_t {
    uint8_t bytes[8];
    tag_type type;
    int index;
    const char *expected;
};

struct stov_t {
    tag_type type;
    const char *number;
    uint8_t bytes[8];
};

int
val_to_string_basic(void)
{
    int result = 0;
    int errors = 0;
    int count;
    char buff[32];

    struct vtos_t tests[] = {
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_BYTE, 0, "0"},
            {{0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_BYTE, 0, "255"},
            {{0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_BYTE, 0, "128"},
            {{0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_SINT, 0, "-128"},
            {{0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_UINT, 0, "256"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_UINT, 0, "0"},
            {{0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_UINT, 0, "65535"},
            {{0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_WORD, 0, "256"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_WORD, 0, "0"},
            {{0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_WORD, 0, "65535"},
            {{0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_INT, 0, "-1"},
            {{0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_INT, 0, "32767"},
            {{0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_INT, 0, "-32768"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_INT, 0, "0"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_UDINT, 0, "0"},
            {{0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_UDINT, 0, "256"},
            {{0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00}, DAX_UDINT, 0, "4294967295"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_UDINT, 0, "0"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_DWORD, 0, "0"},
            {{0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_DWORD, 0, "256"},
            {{0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00}, DAX_DWORD, 0, "4294967295"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_DWORD, 0, "0"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_DINT, 0, "0"},
            {{0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00}, DAX_DINT, 0, "-2147483648"},
            {{0xFF,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00}, DAX_DINT, 0, "2147483647"},
            {{0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00}, DAX_DINT, 0, "-1"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_REAL, 0, "0"},
            {{0x1F,0x85,0x6B,0x3E,0x00,0x00,0x00,0x00}, DAX_REAL, 0, "0.23"},
            {{0xD8,0x0F,0x49,0x40,0x00,0x00,0x00,0x00}, DAX_REAL, 0, "3.141592"},
            {{0x20,0xBC,0xBE,0x4C,0x00,0x00,0x00,0x00}, DAX_REAL, 0, "1e+08"},
            {{0x94,0x48,0x84,0x66,0x00,0x00,0x00,0x00}, DAX_REAL, 0, "3.123456e+23"},
            {{0x94,0x48,0x84,0xE6,0x00,0x00,0x00,0x00}, DAX_REAL, 0, "-3.123456e+23"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_ULINT, 0, "0"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80}, DAX_ULINT, 0, "9223372036854775808"},
            {{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}, DAX_ULINT, 0, "18446744073709551615"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_LWORD, 0, "0"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80}, DAX_LWORD, 0, "9223372036854775808"},
            {{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}, DAX_LWORD, 0, "18446744073709551615"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_LINT, 0, "0"},
            {{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}, DAX_LINT, 0, "-1"},
            {{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F}, DAX_LINT, 0, "9223372036854775807"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80}, DAX_LINT, 0, "-9223372036854775808"},
            {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, DAX_LREAL, 0, "0"},
            {{0xE0,0xDB,0x7E,0xC3,0x12,0x89,0xD0,0x44}, DAX_LREAL, 0, "3.12345678911234e+23"},
            {{0xE0,0xDB,0x7E,0xC3,0x12,0x89,0xD0,0xC4}, DAX_LREAL, 0, "-3.12345678911234e+23"},
            {{0x9A,0x99,0x99,0x99,0x99,0x99,0xB9,0x3F}, DAX_LREAL, 0, "0.1"}
    };
    count = sizeof(tests)/sizeof(struct vtos_t);
    for(int n=0;n<count;n++) {
        result = dax_val_to_string(buff, 32, tests[n].type, tests[n].bytes, tests[n].index);
        if(result) {
            printf("dax_val_to_string() returned error, index %d\n", n);
            errors++;
        }
        if(strcmp(buff, tests[n].expected)) {
            printf("string_to_val_basic() value mismatch, index %d\n", n);
            errors++;
        }
    }
    return result;
}

int
string_to_val_basic(void)
{
    int result = 0;
    int errors = 0;
    int count;
    uint8_t buff[8];

    struct stov_t tests[] = {
            {DAX_BYTE, "1", {0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_BYTE, "128", {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_BYTE, "255", {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_SINT, "-1", {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_SINT, "-128", {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_SINT, "1", {0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_SINT, "127", {0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_WORD, "0", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_WORD, "128", {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_WORD, "255", {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_WORD, "256", {0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_WORD, "65535", {0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_UINT, "0", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_UINT, "128", {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_UINT, "255", {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_UINT, "256", {0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_UINT, "65535", {0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_INT, "-1", {0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_INT, "-128", {0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_INT, "128", {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_INT, "255", {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_INT, "256", {0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_INT, "-32768", {0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_INT, "32767", {0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_DWORD, "128", {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_DWORD, "0", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_DWORD, "255", {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_DWORD, "256", {0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_DWORD, "4294967295", {0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00}},
            {DAX_UDINT, "128", {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_UDINT, "0", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_UDINT, "255", {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_UDINT, "256", {0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_UDINT, "4294967295", {0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00}},
            {DAX_DINT, "-1", {0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00}},
            {DAX_DINT, "-128", {0x80,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00}},
            {DAX_DINT, "128", {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_DINT, "255", {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_DINT, "256", {0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_DINT, "-2147483648", {0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00}},
            {DAX_DINT, "2147483647", {0xFF,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00}},
            {DAX_LWORD, "128", {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_LWORD, "0", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_LWORD, "255", {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_LWORD, "256", {0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_LWORD, "18446744073709551615", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}},
            {DAX_ULINT, "128", {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_ULINT, "0", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_ULINT, "255", {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_ULINT, "256", {0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_ULINT, "18446744073709551615", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}},
            {DAX_LINT, "128", {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_LINT, "0", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_LINT, "-1", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}},
            {DAX_LINT, "-128", {0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}},
            {DAX_LINT, "255", {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_LINT, "256", {0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_LINT, "-9223372036854775808", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80}},
            {DAX_LINT, "9223372036854775807", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F}},
            {DAX_REAL, "0", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_REAL, "0.23", {0x1F,0x85,0x6B,0x3E,0x00,0x00,0x00,0x00}},
            {DAX_REAL, "3.141592", {0xD8,0x0F,0x49,0x40,0x00,0x00,0x00,0x00}},
            {DAX_REAL, "1e+08", {0x20,0xBC,0xBE,0x4C,0x00,0x00,0x00,0x00}},
            {DAX_REAL, "3.123456e+23", {0x94,0x48,0x84,0x66,0x00,0x00,0x00,0x00}},
            {DAX_REAL, "-3.123456e+23", {0x94,0x48,0x84,0xE6,0x00,0x00,0x00,0x00}},
            {DAX_LREAL, "0", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
            {DAX_LREAL, "3.12345678911234e+23", {0xE0,0xDB,0x7E,0xC3,0x12,0x89,0xD0,0x44}},
            {DAX_LREAL, "-3.12345678911234e+23", {0xE0,0xDB,0x7E,0xC3,0x12,0x89,0xD0,0xC4}},
            {DAX_LREAL, "0.1", {0x9A,0x99,0x99,0x99,0x99,0x99,0xB9,0x3F}}
    };
    count = sizeof(tests)/sizeof(struct stov_t);
    for(int n=0;n<count;n++) {
        result = dax_string_to_val((char *)tests[n].number , tests[n].type, buff, NULL, 0);
        if(result) {
            printf("dax_string_to_val() returned error, index %d\n", n);
            errors++;
        }
        for(int i=0;i<TYPESIZE(tests[n].type)/8; i++) {
            if(buff[i] != tests[n].bytes[i]) {
                printf("string_to_val_basic() value mismatch, index %d\n", n);
                errors++;
            }
        }

    }
    return errors;
}

int
string_to_val_underflow(void)
{
    int result = 0;
    int errors = 0;
    int count;
    uint8_t buff[8];

    struct stov_t tests[] = {
                {DAX_BYTE, "-1", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_SINT, "-129", {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_WORD, "-1", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_UINT, "-1", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_INT, "-32769", {0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_DWORD, "-1", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_UDINT, "-1", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_DINT, "-2147483649", {0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00}},
                {DAX_LWORD, "-1", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_ULINT, "-1", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_LINT, "-9223372036854775809", {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80}},
    };
    count = sizeof(tests)/sizeof(struct stov_t);
    for(int n=0;n<count;n++) {
        result = dax_string_to_val((char *)tests[n].number , tests[n].type, buff, NULL, 0);
        if(result != ERR_UNDERFLOW) {
            printf("dax_string_to_val() returned error, index %d\n", n);
            errors++;
        }
        for(int i=0;i<TYPESIZE(tests[n].type)/8; i++) {
            if(buff[i] != tests[n].bytes[i]) {
                printf("string_to_val_underflow() value mismatch, index %d\n", n);
                errors++;
            }
        }

    }
    return errors;
}

int
string_to_val_overflow(void)
{
    int result = 0;
    int errors = 0;
    int count;
    uint8_t buff[8];

    struct stov_t tests[] = {
                {DAX_BYTE, "256", {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_SINT, "128", {0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_WORD, "65536", {0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_UINT, "65536", {0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_INT, "32768", {0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00}},
                {DAX_DWORD, "4294967296", {0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00}},
                {DAX_UDINT, "4294967296", {0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00}},
                {DAX_DINT, "2147483648", {0xFF,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00}},
                {DAX_LWORD, "18446744073709551616", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}},
                {DAX_ULINT, "18446744073709551616", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}},
                {DAX_LINT, "9223372036854775808", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F}},
    };
    count = sizeof(tests)/sizeof(struct stov_t);
    for(int n=0;n<count;n++) {
        result = dax_string_to_val((char *)tests[n].number , tests[n].type, buff, NULL, 0);
        if(result != ERR_OVERFLOW) {
            printf("dax_string_to_val() returned error, index %d\n", n);
            errors++;
        }
        for(int i=0;i<TYPESIZE(tests[n].type)/8; i++) {
            if(buff[i] != tests[n].bytes[i]) {
                printf("string_to_val_underflow() value mismatch, index %d\n", n);
                errors++;
            }
        }

    }
    return errors;
}


int
main(int argc, char *argv[])
{
    int result = 0;
    result += val_to_string_basic();
    result += string_to_val_basic();
    result += string_to_val_underflow();
    result += string_to_val_overflow();
    if(result == 0) {
        printf("OK\n");
        exit(0);
    } else {
        printf("FAIL\n");
        exit(-1);
    }
}
